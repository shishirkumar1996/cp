This folder serves as a template for all the algos and data structures which I might forget in the future.

Algorithms and their Uses


Algorithm                                                   Use

1. tarjan algorithm          ----->    for finding strongly connected component
2. maximum bipartite matching ---->    for finding maximum matching in bipartite graph
3. Edmond Karp(ford fulkerson) algorithm ------>    maximum flow from source to sink in a graph . Edmon karp is a fully applied algorithm of ford fulkerson method
4. hopcroft-karp algorithm    ---->    for finding maximum matching in bipartite graph. It can also be done with ford fulkerson method by just connecting source with all the vertices in first set and connecting sink with all the vertices in second set

5. coin change problem        ---->     dynamic programming problem to check number of ways to return certain amount(change) given infinite number of coins of some types
6. lowest common ancestor(binary lifting method) ---->     in trees, we need to find the lowest common ancestor of two given nodes.
7. Extended euclidean algorithm ------> Finds integer coefficient  x and y such that ax+by = gcd(a,b) ( a and b are given) . The extended Euclidean algorithm is particularly useful when a and b are coprime (or gcd is 1). Since x is the modular multiplicative inverse of “a modulo b”, and y is the modular multiplicative inverse of “b modulo a”. As ax modulo b = 1, therefore a and x are modular multiplicative inverse. ( need to learn it)
8. modular multiplicative inverse ------> used in chinese remainder theorem
9. chinese remainder theorem -----> two arrays are given num[1..n],rem[1..n] and every pair num[i] and rem[i] is coprime, we need to find minimum positive number such that x%num[i] = rem[i] for every pair.
10. modular exponentiation -------> for faster calculation of x^y
11. breadth first search -------> traversal technique
12. depth first search ------> traversal technique(both iterative and recursive)
13. dijkstra algorithm -------> greedy algorithm to find minimum distance from one vertex to all other vertices. Time complexity is O(VlogV)
14. prim algorithm --------> for finding minimum spanning tree of a graph( greedy algorithm)
15. kruskal algorithm-------> for finding minimum spanning tree of a graph
16. heavy-light decomposition algorithm ----> to divide the tree into various chains in order to minimize the query time. As there are atmost log N chains and solution for each chain can be answered in O(log n) time,therefore total time complexity becomes O((logn)^2). Each continues on the vertex which have the greatest number of elements in its subtree
17. merge sort        -------> sorting method with O(nlogn) complexity and works on divide and conquer approach
18. quick sort ----->it also works on divide and conquer approach. A pivot is being selected and the array is divided on the basis of this pivot and then sorted. complexity is O(nlogn)
19. radix sort ------> complexity is O((base b)log(k)*(n+b)) where b is base for representing numbers, n is the number of elements and k is the maximum possible value.Can work in linear time.
20. binary search ----> works on sorted list, to search for a particular element. divide and conquer approach. O(logn) time.
21. z-algorithm ------> find all occurences of a pattern in a text in linear time. If length of text is m and length of pattern is m, then total time taken is O(m+n) with linear space complexity.Same time and space complexity as KMP algo but simpler to understand.works on z-array in which length of longest starting from str[i] is also a prefix of str[0..n-1].
22. kmp algorithm -------> find all occurences of a pattern in a text in linear space complexity.
23. fractional knapsack problem -----> greedy approach works for this problem as we can take fraction of an item.
24. 0-1 knapsack problem ------> dynamic programming approach works for this problem as you can either take full item or not at all.
25. rod cutting problem ----> dynamic programming approach.divide the rod into such parts so that the value of the parts become maximum
26. bellman-ford algorithm ----> dynamic programming approach. Finds shortest paths from sources to all vertices in the given graph.The graph may contain negative weight edges.Time complexity is O(VE) where V is number of vertices, E is number of edges. In both bellman ford and prim algorithm, graph is represented as array of edges.
27. floyd warshall algorithm ------> dynamic programming approach. calculates shortest path from each vertex to every other vertex
28. longest increasing subsequence ------> dynamic programming approach has time complexity of O(n^2). But here a method of O(nlogn) is being described.
In dynamic programming approach, we just check all the smaller indices for a given index.
29. longest common subsequence -----> dynamic programming approach. Time complexity is O(mn) where m and n are sizes of two strings.
30. rabin-karp algorithm -------> finds a pattern in a string just like z-algorithm and kmp algorithm. time complexity is O(m+n). Works by calculating hash values of the string.
31. sudoku solving ------> use of backtrack to solve 3*3 sudoku
32. n-queen problem -------> backtracking problem. number of ways to keep n queens on n*n chessboard so that none of them attack any other queen. here just one orientation is being shown. Complexity is exponential. Therefore pruning is also applied to increase efficiency.
33. matrix exponentiation algorithm ------> here, matrix exponentiation is done to calculate f(n) = a*f(n-1)+b*f(n-2)+c*f(n-3) in O(logn) time. similarly fibonacii sequence and other sequence numbers can also be calculated in o(logn) time. the matrices changes as the sequences changes.
34. closest pair of point ------> given n points in the plane,find closes pair of point among the given points. algorithm has divide and conquer approach. The time complexity is O(n(logn)^2).


Data structure

1. disjoint set union (DSU) ------> can be used for 1) cycle checks  (check kruskal for implementation)
